[["index.html", "Mastering Shiny Solutions Welcome Note Boxes License Acknowledgements", " Mastering Shiny Solutions Maya Gans and Marly Gotti (updated on 2021-01-02) Welcome This book offers solutions to the exercises from Hadley Wickham’s book Mastering Shiny. It is a work in progress and under active development. The code for this book can be found on GitHub. Your PRs and suggestions are very welcome. Note Boxes We use three different types of boxes throughout the book. This “note” box denotes we were either unclear what the exercise was asking or have follow up questions. This “TODO” box denotes that the exercises in the chapter have either partial solutions or have yet to be reviewed. License This work by Maya Gans and Marly Gotti is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License Acknowledgements "],["preface.html", "Chapter 1 Preface", " Chapter 1 Preface There are no exercises in this chapter. "],["your-first-shiny-app.html", "Chapter 2 Your First Shiny App Exercise 2.8.2 Exercise 2.8.3 Exercise 2.8.4 Exercise 2.8.5", " Chapter 2 Your First Shiny App Exercise 2.8.1 Create an app that greets the user by name. You don’t know all the functions you need to do this yet, so I’ve included some lines of code below. Figure out which lines you’ll use and then copy and paste them into the right place in a Shiny app. textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;) renderText({ paste0(&quot;Hello &quot;, input$name) }) numericInput(&quot;age&quot;, &quot;How old are you?&quot;) textOutput(&quot;greeting&quot;) tableOutput(&quot;mortgage&quot;) renderPlot(&quot;histogram&quot;, { hist(rnorm(1000)) }, res = 96) Solution. Solution In the UI, we will need a textInput for the user to input text, and a textOutput to output any custom text to the app. The corresponding server function to textOutput is renderText, which we can use to compose the output element we’ve named “greeting”. library(shiny) ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name) }) } shinyApp(ui, server) Exercise 2.8.2 Suppose your friend wants to design an app that allows the user to set a number (x) between 1 and 50, and displays the result of multiplying this number by 5. This is their first attempt: ui &lt;- fluidPage( sliderInput(&quot;x&quot;, label = &quot;If x is&quot;, min = 1, max = 50, value = 30), &quot;then x times 5 is&quot;, textOutput(&quot;product&quot;) ) server &lt;- function(input, output, session) { output$product &lt;- renderText({ x * 5 }) } But unfortunately it has an error: Can you help them find and correct the error? Solution. Solution The error here arises because on the server side we need to write input$x rather than x. By writing x, we are looking for element x which doesn’t exist in the Shiny environment; x only exists within the read-only object input. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, label = &quot;If x is&quot;, min = 1, max = 50, value = 30), &quot;then x times 5 is&quot;, textOutput(&quot;product&quot;) ) server &lt;- function(input, output, session) { output$product &lt;- renderText({ input$x * 5 }) } shinyApp(ui, server) Exercise 2.8.3 Extend the app from the previous exercise to allow the user to set the value of the multiplier, y, so that the app yields the value of x * y. The final result should look like this: Solution. Solution Let us add another sliderInput with ID y, and use both input$x and input$y to calculate output$product. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, label = &quot;If x is&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, label = &quot;and y is&quot;, min = 1, max = 50, value = 30), &quot;then x multiplied by y is&quot;, textOutput(&quot;product&quot;) ) server &lt;- function(input, output, session) { output$product &lt;- renderText({ input$x * input$y }) } shinyApp(ui, server) Exercise 2.8.4 Replace the UI and server components of your app from the previous exercise with the UI and server components below, run the app, and describe the app’s functionality. Then reduce the duplication in the app by using a reactive expression. ui &lt;- fluidPage( sliderInput(&quot;x&quot;, &quot;If x is&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, &quot;and y is&quot;, min = 1, max = 50, value = 5), &quot;then, (x * y) is&quot;, textOutput(&quot;product&quot;), &quot;and, (x * y) + 5 is&quot;, textOutput(&quot;product_plus5&quot;), &quot;and (x * y) + 10 is&quot;, textOutput(&quot;product_plus10&quot;) ) server &lt;- function(input, output, session) { output$product &lt;- renderText({ product &lt;- input$x * input$y product }) output$product_plus5 &lt;- renderText({ product &lt;- input$x * input$y product + 5 }) output$product_plus10 &lt;- renderText({ product &lt;- input$x * input$y product + 10 }) } Solution. Solution The application above has two numeric inputs input$x and input$y. It computes three values: x*y, x*y + 5, and x*y + 10. We can reduce duplication by making the product variable a reactive value and using it within all three outputs. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, &quot;If x is&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, &quot;and y is&quot;, min = 1, max = 50, value = 5), &quot;then, (x * y) is&quot;, textOutput(&quot;product&quot;), &quot;and, (x * y) + 5 is&quot;, textOutput(&quot;product_plus5&quot;), &quot;and (x * y) + 10 is&quot;, textOutput(&quot;product_plus10&quot;) ) server &lt;- function(input, output, session) { product &lt;- reactive(input$x * input$y) output$product &lt;- renderText( product() ) output$product_plus5 &lt;- renderText( product() + 5 ) output$product_plus10 &lt;- renderText( product() + 10 ) } shinyApp(ui, server) Exercise 2.8.5 The following app is very similar to one you’ve seen earlier in the chapter: you select a dataset from a package (this time we’re using the ggplot2 package) and the app prints out a summary and plot of the data. It also follows good practice and makes use of reactive expressions to avoid redundancy of code. However there are three bugs in the code provided below. Can you find and fix them? library(ggplot2) datasets &lt;- data(package = &quot;ggplot2&quot;)$results[c(2, 4, 10), &quot;Item&quot;] ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, &quot;Dataset&quot;, choices = datasets), verbatimTextOutput(&quot;summary&quot;), tableOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { dataset &lt;- reactive({ get(input$dataset, &quot;package:ggplot2&quot;) }) output$summmry &lt;- renderPrint({ summary(dataset()) }) output$plot &lt;- renderPlot({ plot(dataset) }, res = 96) } Solution. Solution The app contains the following three bugs: In the UI, the tableOutput object should really be a plotOutput. In the server, the word “summry” in output$summry is misspelled. In the server, the plot function in the output$plot should call dataset() rather than the reactive object. The fixed app looks as follows: library(ggplot2) datasets &lt;- data(package = &quot;ggplot2&quot;)$results[c(2, 4, 10), &quot;Item&quot;] ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, &quot;Dataset&quot;, choices = datasets), verbatimTextOutput(&quot;summary&quot;), # 1. Change tableOutput to plotOutput. plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { dataset &lt;- reactive({ get(input$dataset, &quot;package:ggplot2&quot;) }) # 2. Change summry to summary. output$summary &lt;- renderPrint({ summary(dataset()) }) output$plot &lt;- renderPlot({ # 3. Change dataset to dataset(). plot(dataset()) }) } shinyApp(ui, server) "],["basic-ui.html", "Chapter 3 Basic UI", " Chapter 3 Basic UI Exercise 3.2.8.1 When space is at a premium, it’s useful to label text boxes using a placeholder that appears inside the text entry area. How do you call textInput() to generate the UI below? Solution. Solution Looking at the output of ?textInput, we see the argument placeholder which takes: A character string giving the user a hint as to what can be entered into the control. Therefore, we can use the textInput with arguments as shown below to generate the desired UI. textInput(&quot;text&quot;, &quot;&quot;, placeholder = &quot;Your name&quot;) Exercise 3.2.8.2 Carefully read the documentation for sliderInput() to figure out how to create a date slider, as shown below. Solution. Solution To create such slider, we need the following code. sliderInput( &quot;dates&quot;, &quot;When should we deliver?&quot;, min = as.Date(&quot;2019-08-09&quot;), max = as.Date(&quot;2019-08-16&quot;), value = as.Date(&quot;2019-08-10&quot;) ) Exercise 3.2.8.3 If you have a moderately long list, it’s useful to create sub-headings that break the list up into pieces. Read the documentation for selectInput() to figure out how. (Hint: the underlying HTML is called &lt;optgroup&gt;.) Solution. Solution We can make the choices argument a list of key-value pairs where the keys represent the sub-headings and the values are lists containing the categorized elements by keys. As an illustration, the following example separates animal breeds into two keys (categories): “dogs” and “cats”. selectInput( &quot;breed&quot;, &quot;Select your favorite animal breed:&quot;, choices = list(`dogs` = list(&#39;German Shepherd&#39;, &#39;Bulldog&#39;, &#39;Labrador Retriever&#39;), `cats` = list(&#39;Persian cat&#39;, &#39;Bengal cat&#39;, &#39;Siamese Cat&#39;)) ) If you run the snippet above in the console, you will see the HTML code needed to generate the input. You can also see the &lt;optgroup&gt; as hinted in the exercise. Exercise 3.2.8.4 Create a slider input to select values between 0 and 100 where the interval between each selectable value on the slider is 5. Then, add animation to the input widget so when the user presses play the input widget scrolls through automatically. Solution. Solution We can set the interval between each selectable value using the step argument. In addition, by setting animate = TRUE, the slider will automatically animate once the user presses play. sliderInput(&quot;number&quot;, &quot;Select a number:&quot;, min = 0, max = 100, value = 0, step = 5, animate = TRUE) Exercise 3.2.8.5 Using the following numeric input box the user can enter any value between 0 and 1000. What is the purpose of the step argument in this widget? numericInput(&quot;number&quot;, &quot;Select a value&quot;, value = 150, min = 0, max = 1000, step = 50) Solution. Solution The step argument is the amount by which the numericInput value is incremented (resp. decreased) when the user clicks the up (resp. down) arrow. In the previous example, when the user clicks the up (resp. down) arrow the numeric value will increase (resp. decrease) by 50. Note: by using a numericInput the user still has the ability to type any number. Exercise 3.3.5.1 Re-create the Shiny app from the plots section, this time setting height to 300px and width to 700px. Solution. Solution The function plotOutput can take on static width and height arguments. Using the app from the plots section, we only need to add the height argument and modify the width. library(shiny) ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;700px&quot;, height = &quot;300px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5), res = 96) } shinyApp(ui, server) Exercise 3.3.5.2 Update the options for renderDataTable() below so that the table is displayed, but nothing else (i.e. remove the search, ordering, and filtering commands). You’ll need to read ?renderDataTable and review the options at https://datatables.net/reference/option/. ui &lt;- fluidPage( dataTableOutput(&quot;table&quot;) ) server &lt;- function(input, output, session) { output$table &lt;- renderDataTable(mtcars, options = list(pageLength = 5)) } Solution. Solution We can achieve this by setting ordering and searching to FALSE within the options list. library(shiny) ui &lt;- fluidPage( dataTableOutput(&quot;table&quot;) ) server &lt;- function(input, output, session) { output$table &lt;- renderDataTable( mtcars, options = list(ordering = FALSE, searching = FALSE)) } shinyApp(ui, server) Exercise 3.4.6.1 Create an app that contains two plots, each of which takes up half the app (regardless of what size the whole app is) Solution. Solution When creating the layout of a shiny app, you can use the fluidRow function to control the width of the objects it contains. This function can have columns and such columns can be set to have widths ranging from 1-12. Note that columns width within a fluidRow container should add up to 12. For our exercise, we need two columns of 50% width each, i.e., we should set the width of each column to 6. library(shiny) ui &lt;- fluidPage( fluidRow( column(width = 6, plotOutput(&quot;plot1&quot;)), column(width = 6, plotOutput(&quot;plot2&quot;)) ) ) server &lt;- function(input, output, session) { output$plot1 &lt;- renderPlot(plot(1:5)) output$plot2 &lt;- renderPlot(plot(1:5)) } shinyApp(ui, server) Exercise 3.4.6.2 Modify the Central Limit Theorem app so that the sidebar is on the right instead of the left. Solution. Solution Looking at ?sidebarLayout we can simply set the position argument to right. We only need to modify the UI of the app. ui &lt;- fluidPage( headerPanel(&quot;Central limit theorem&quot;), sidebarLayout( position = &quot;right&quot;, sidebarPanel( numericInput(&quot;m&quot;, &quot;Number of samples:&quot;, 2, min = 1, max = 100) ), mainPanel( plotOutput(&quot;hist&quot;) ) ) ) Exercise 3.4.6.3 Browse the themes available in the shinythemes package, pick an attractive theme, and apply it to the Central Limit Theorem app. Solution. Solution We can browse the themes here and apply it by setting the theme argument within fluidPage to shinythemes::shinytheme(&quot;theme_name&quot;) library(shinythemes) ui &lt;- fluidPage( theme = shinythemes::shinytheme(&quot;darkly&quot;), headerPanel(&quot;Central limit theorem&quot;), sidebarLayout( position = &quot;right&quot;, sidebarPanel( numericInput(&quot;m&quot;, &quot;Number of samples:&quot;, 2, min = 1, max = 100) ), mainPanel( plotOutput(&quot;hist&quot;) ) ) ) server &lt;- function(input, output, session) { output$hist &lt;- renderPlot({ means &lt;- replicate(1e4, mean(runif(input$m))) hist(means, breaks = 20) }) } shinyApp(ui, server) "],["basic-reactivity.html", "Chapter 4 Basic Reactivity", " Chapter 4 Basic Reactivity Exercise 4.3.6.1 Draw the reactive graph for the following server functions: server1 &lt;- function(input, output, session) { c &lt;- reactive(input$a + input$b) e &lt;- reactive(c() + input$d) output$f &lt;- renderText(e()) } server2 &lt;- function(input, output, session) { x &lt;- reactive(input$x1 + input$x2 + input$x3) y &lt;- reactive(input$y1 + input$y2) output$z &lt;- renderText(x() / y()) } server3 &lt;- function(input, output, session) { d &lt;- reactive(c() ^ input$d) a &lt;- reactive(input$a * 10) c &lt;- reactive(b() / input$c) b &lt;- reactive(a() + input$b) } Solution. Solution To create the reactive graph we need to consider the inputs, reactive expressions, and outputs of the app. For server1 we have the following objects: inputs: input$a, input$b, and input$d reactives: c() and e() outputs: output$f Inputs input$a and input$b are used to create c(), which is combined with input$d to create e(). The output depends only on e(). For server2 we have the following objects: inputs: input$y1, input$y2, input$x1, input$x2, input$x3 reactives: y() and x() outputs: output$z Inputs input$y1 and input$y2 are needed to create the reactive y(). In addition, inputs input$x1, input$x2, and input$x3 are required to create the reactive x(). The output depends on both x() and y(). For server3 we have the following objects: inputs: input$a, input$b, input$c, input$d reactives: a(), b(), c(), d() As we can see below, a() relies on input$a, b() relies on both a() and input$b, and c() relies on both b() and input$c. The final output depends on both c() and input$d. Exercise 4.3.6.2 Why will this code fail? var &lt;- reactive(df[input$var]) range &lt;- reactive(range(var(), na.rm = TRUE)) Why is var() a bad name for a reactive? Solution. Solution This code doesn’t work because we called our reactive range, so when we call the range function we’re actually calling our new reactive. If we change the name of the reactive from range to col_range then the code will work. Similarly, var() is not a good name for a reactive because it’s already a function to compute the variance of x! ?cor::var library(shiny) df &lt;- mtcars ui &lt;- fluidPage( selectInput(&quot;var&quot;, NULL, choices = colnames(df)), verbatimTextOutput(&quot;debug&quot;) ) server &lt;- function(input, output, session) { col_var &lt;- reactive( df[input$var] ) col_range &lt;- reactive({ range(col_var(), na.rm = TRUE ) }) output$debug &lt;- renderPrint({ col_range() }) } shinyApp(ui = ui, server = server) Exercise 4.4.6.1 Use reactive expressions to reduce the duplicated code in the following simple apps. Solution. Solution Unclear about the apps mentioned in the exercise. "],["case-study-er-injuries.html", "Chapter 5 Case Study: ER Injuries", " Chapter 5 Case Study: ER Injuries Exercise 5.8.1 Draw the reactive graph for each app. Solution. Solution Prototype The prototype application has a single input, input$code, which is used to generate the selected() reactive. This reactive is used directly in 3 outputs, output$diag, output$body_part, and output$location, and it is also used indirectly in the output$age_sex plot via the summary() reactive. Rate vs. Count Building on the prototype, we create a second input input$y which is used along with the summary() reactive to create the output$age_sex plot. Narrative Building on the application once more, we create an output$narrative that depends on the selected() reactive and a new input, input$story. Exercise 5.8.2 What happens if you flip fct_infreq() and fct_lump() in the code that reduces the summary tables? Solution. Solution As in the book, we will use the datasets injuries, products, and population appearing here: https://github.com/hadley/mastering-shiny/blob/master/neiss/data.R. Flipping the order of fct_infreq() and fct_lump() will only change the factor levels order. In particular, the function fct_infreq() orders the factor levels by frequency, and the function fct_lump() also orders the factor levels by frequency but it will only keep the top n factors and label the rest as Other. Let us look at the top five levels in terms of count within the diag column in the injuries dataset: injuries %&gt;% group_by(diag) %&gt;% count() %&gt;% arrange(-n) %&gt;% head(5) ## # A tibble: 5 x 2 ## # Groups: diag [5] ## diag n ## &lt;chr&gt; &lt;int&gt; ## 1 Other Or Not Stated 44937 ## 2 Fracture 43093 ## 3 Laceration 39230 ## 4 Strain, Sprain 37002 ## 5 Contusion Or Abrasion 35259 If we apply fct_infreq() first, then it will reorder the factor levels in descending order as seen in the previous output. If afterwards we apply fct_lump(), then it will lump together everything after the nth most commonly seen level. diag &lt;- injuries %&gt;% mutate(diag = fct_lump(fct_infreq(diag), n = 5)) %&gt;% pull(diag) levels(diag) ## [1] &quot;Other Or Not Stated&quot; &quot;Fracture&quot; &quot;Laceration&quot; ## [4] &quot;Strain, Sprain&quot; &quot;Contusion Or Abrasion&quot; &quot;Other&quot; Conversely, if we apply fct_lump() first, then it will label the most frequently seen factor level as “Other”. If afterwards we apply fct_infreq(), then it will label the first level as “Other” and not as “Other Or Not Stated”, which was the case for the previous code. diag &lt;- injuries %&gt;% mutate(diag = fct_infreq(fct_lump(diag, n = 5))) %&gt;% pull(diag) levels(diag) ## [1] &quot;Other&quot; &quot;Other Or Not Stated&quot; &quot;Fracture&quot; ## [4] &quot;Laceration&quot; &quot;Strain, Sprain&quot; &quot;Contusion Or Abrasion&quot; Exercise 5.8.3 Add an input control that lets the user decide how many rows to show in the summary tables. Solution. Solution Our function count_top is responsible for grouping our variables into a set number of factors, lumping the rest of the values into “Other”. The function has an argument n which is set to 5. By creating a numericInput called rows we can let the user set the number of fct_infreq dynamically. However, because fct_infreq is the number of factors + Other, we need to subtract 1 from what the user selects in order to display the number of rows they input. library(shiny) library(forcats) library(dplyr) library(ggplot2) # Note: these exercises use the datasets `injuries`, `products`, and # `population` as created here: # https://github.com/hadley/mastering-shiny/blob/master/neiss/data.R count_top &lt;- function(df, var, n = 5) { df %&gt;% mutate({{ var }} := fct_lump(fct_infreq({{ var }}), n = n)) %&gt;% group_by({{ var }}) %&gt;% summarise(n = as.integer(sum(weight))) } ui &lt;- fluidPage( fluidRow( column(8, selectInput(&quot;code&quot;, &quot;Product&quot;, choices = setNames(products$prod_code, products$title), width = &quot;100%&quot;) ), column(2, numericInput(&quot;rows&quot;, &quot;Number of Rows&quot;, min = 1, max = 10, value = 5)), column(2, selectInput(&quot;y&quot;, &quot;Y Axis&quot;, c(&quot;rate&quot;, &quot;count&quot;))) ), fluidRow( column(4, tableOutput(&quot;diag&quot;)), column(4, tableOutput(&quot;body_part&quot;)), column(4, tableOutput(&quot;location&quot;)) ), fluidRow( column(12, plotOutput(&quot;age_sex&quot;)) ), fluidRow( column(2, actionButton(&quot;story&quot;, &quot;Tell me a story&quot;)), column(10, textOutput(&quot;narrative&quot;)) ) ) server &lt;- function(input, output, session) { selected &lt;- reactive(injuries %&gt;% filter(prod_code == input$code)) # Find the maximum possible of rows. max_no_rows &lt;- reactive( max(length(unique(selected()$diag)), length(unique(selected()$body_part)), length(unique(selected()$location))) ) # Update the maximum value for the numericInput based on max_no_rows(). observeEvent(input$code, { updateNumericInput(session, &quot;rows&quot;, max = max_no_rows()) }) table_rows &lt;- reactive(input$rows - 1) output$diag &lt;- renderTable( count_top(selected(), diag, n = table_rows()), width = &quot;100%&quot;) output$body_part &lt;- renderTable( count_top(selected(), body_part, n = table_rows()), width = &quot;100%&quot;) output$location &lt;- renderTable( count_top(selected(), location, n = table_rows()), width = &quot;100%&quot;) summary &lt;- reactive({ selected() %&gt;% count(age, sex, wt = weight) %&gt;% left_join(population, by = c(&quot;age&quot;, &quot;sex&quot;)) %&gt;% mutate(rate = n / population * 1e4) }) output$age_sex &lt;- renderPlot({ if (input$y == &quot;count&quot;) { summary() %&gt;% ggplot(aes(age, n, colour = sex)) + geom_line() + labs(y = &quot;Estimated number of injuries&quot;) + theme_grey(15) } else { summary() %&gt;% ggplot(aes(age, rate, colour = sex)) + geom_line(na.rm = TRUE) + labs(y = &quot;Injuries per 10,000 people&quot;) + theme_grey(15) } }) output$narrative &lt;- renderText({ input$story selected() %&gt;% pull(narrative) %&gt;% sample(1) }) } shinyApp(ui, server) Exercise 5.8.4 Provide a way to step through every narrative systematically with forward and backward buttons. Advanced: Make the list of narratives “circular” so that advancing forward from the last narrative takes you to the first. Solution. Solution We can add two buttons prev_story and next_story to iterate through the narrative. In addition, we can include a reactive value, story, that keeps track of the current position in the narrative. When the button prev_story is pressed, story decreases by one. Similarly, when the button next_story is pressed, story increases by one. To do the advanced part, we use the mod function. This allows us to keep story between 1 and the current narrative’s length, and simulate the “circular” motion. library(shiny) library(forcats) library(dplyr) library(ggplot2) # Note: these exercises use the datasets `injuries`, `products`, and # `population` as created here: # https://github.com/hadley/mastering-shiny/blob/master/neiss/data.R count_top &lt;- function(df, var, n = 5) { df %&gt;% mutate({{ var }} := fct_lump(fct_infreq({{ var }}), n = n)) %&gt;% group_by({{ var }}) %&gt;% summarise(n = as.integer(sum(weight))) } ui &lt;- fluidPage( fluidRow( column(8, selectInput(&quot;code&quot;, &quot;Product&quot;, choices = setNames(products$prod_code, products$title), width = &quot;100%&quot;) ), column(2, numericInput(&quot;rows&quot;, &quot;Number of Rows&quot;, min = 1, max = 10, value = 5)), column(2, selectInput(&quot;y&quot;, &quot;Y Axis&quot;, c(&quot;rate&quot;, &quot;count&quot;))) ), fluidRow( column(4, tableOutput(&quot;diag&quot;)), column(4, tableOutput(&quot;body_part&quot;)), column(4, tableOutput(&quot;location&quot;)) ), fluidRow( column(12, plotOutput(&quot;age_sex&quot;)) ), fluidRow( column(2, actionButton(&quot;prev_story&quot;, &quot;Previous story&quot;)), column(2, actionButton(&quot;next_story&quot;, &quot;Next story&quot;)), column(8, textOutput(&quot;narrative&quot;)) ) ) server &lt;- function(input, output, session) { selected &lt;- reactive(injuries %&gt;% filter(prod_code == input$code)) # Find the maximum possible of rows. max_no_rows &lt;- reactive( max(length(unique(selected()$diag)), length(unique(selected()$body_part)), length(unique(selected()$location))) ) # Update the maximum value for the numericInput based on max_no_rows(). observeEvent(input$code, { updateNumericInput(session, &quot;rows&quot;, max = max_no_rows()) }) table_rows &lt;- reactive(input$rows - 1) output$diag &lt;- renderTable( count_top(selected(), diag, n = table_rows()), width = &quot;100%&quot;) output$body_part &lt;- renderTable( count_top(selected(), body_part, n = table_rows()), width = &quot;100%&quot;) output$location &lt;- renderTable( count_top(selected(), location, n = table_rows()), width = &quot;100%&quot;) summary &lt;- reactive({ selected() %&gt;% count(age, sex, wt = weight) %&gt;% left_join(population, by = c(&quot;age&quot;, &quot;sex&quot;)) %&gt;% mutate(rate = n / population * 1e4) }) output$age_sex &lt;- renderPlot({ if (input$y == &quot;count&quot;) { summary() %&gt;% ggplot(aes(age, n, colour = sex)) + geom_line() + labs(y = &quot;Estimated number of injuries&quot;) + theme_grey(15) } else { summary() %&gt;% ggplot(aes(age, rate, colour = sex)) + geom_line(na.rm = TRUE) + labs(y = &quot;Injuries per 10,000 people&quot;) + theme_grey(15) } }) # Store the maximum posible number of stories. max_no_stories &lt;- reactive(length(selected()$narrative)) # Reactive used to save the current position in the narrative list. story &lt;- reactiveVal(1) # Reset the story counter if the user changes the product code. observeEvent(input$code, { story(1) }) # When the user clicks &quot;Next story&quot;, increase the current position in the # narrative but never go beyond the interval [1, length of the narrative]. # Note that the mod function (%%) is keeping `current`` within this interval. observeEvent(input$next_story, { story((story() %% max_no_stories()) + 1) }) # When the user clicks &quot;Previous story&quot; decrease the current position in the # narrative. Note that we also take advantage of the mod function. observeEvent(input$prev_story, { story(((story() - 2) %% max_no_stories()) + 1) }) output$narrative &lt;- renderText({ selected()$narrative[story()] }) } shinyApp(ui, server) "],["workflow.html", "Chapter 6 Workflow", " Chapter 6 Workflow There are no exercises in this chapter. "],["graphics.html", "Chapter 7 Graphics", " Chapter 7 Graphics Exercise 7.6.1 Make a plot with click handle that shows all the data returned in the input. Solution. Solution We can use the allRows argument in nearPoints to see the entire data and add a boolean column that will be true TRUE for the given point (i.e., row) that was clicked. library(shiny) library(ggplot2) ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, click = &quot;plot_click&quot;), tableOutput(&quot;data&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ ggplot(mtcars, aes(wt, mpg)) + geom_point() }, res = 96) output$data &lt;- renderTable({ nearPoints(mtcars, input$plot_click, allRows = TRUE) }) } shinyApp(ui, server) Exercise 7.6.2 Make a plot with click, dblclick, hover, and brush output handlers and nicely display the current selection in the sidebar. Plot the plot in the main panel. Solution. Solution We can use the nearPoints function to extract the data from plot_click, plot_dbl, and plot_hover. We need to use the function brushedPoints to extract the points within the plot_brush area. To ‘nicely’ display the current selection, we will use dataTableOutput. library(shiny) library(ggplot2) # Set options for rendering DataTables. options &lt;- list( autoWidth = FALSE, searching = FALSE, ordering = FALSE, lengthChange = FALSE, lengthMenu = FALSE, pageLength = 5, # Only show 5 rows per page. paging = TRUE, # Enable pagination. Must be set for pageLength to work. info = FALSE ) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( width = 6, h4(&quot;Selected Points&quot;), dataTableOutput(&quot;click&quot;), br(), h4(&quot;Double Clicked Points&quot;), dataTableOutput(&quot;dbl&quot;), br(), h4(&quot;Hovered Points&quot;), dataTableOutput(&quot;hover&quot;), br(), h4(&quot;Brushed Points&quot;), dataTableOutput(&quot;brush&quot;) ), mainPanel(width = 6, plotOutput(&quot;plot&quot;, click = &quot;plot_click&quot;, dblclick = &quot;plot_dbl&quot;, hover = &quot;plot_hover&quot;, brush = &quot;plot_brush&quot;) ) ) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point() }, res = 96) output$click &lt;- renderDataTable( nearPoints(iris, input$plot_click), options = options) output$hover &lt;- renderDataTable( nearPoints(iris, input$plot_hover), options = options) output$dbl &lt;- renderDataTable( nearPoints(iris, input$plot_dbl), options = options) output$brush &lt;- renderDataTable( brushedPoints(iris, input$plot_brush), options = options) } shinyApp(ui, server) Exercise 7.6.3 Compute the limits of the distance scale using the size of the plot. output_size &lt;- function(id) { reactive(c( session$clientData[[paste0(&quot;output_&quot;, id, &quot;_width&quot;)]], session$clientData[[paste0(&quot;output_&quot;, id, &quot;_height&quot;)]] )) } Solution. Solution Let us use the plot’s width and height to estimate the scale limits for our plot. To verify that the recommended limits are correct, click around the plot and watch how the distance scale changes on the legend. These values should oscillate between the recommended limits. Resize the browser’s window to change the width and height reactives. library(shiny) library(ggplot2) df &lt;- data.frame(x = rnorm(100), y = rnorm(100)) ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, click = &quot;plot_click&quot;), textOutput(&quot;width&quot;), textOutput(&quot;height&quot;), textOutput(&quot;scale&quot;) ) server &lt;- function(input, output, session) { # Save the plot&#39;s widht and height. width &lt;- reactive(session$clientData[[&quot;output_plot_width&quot;]]) height &lt;- reactive(session$clientData[[&quot;output_plot_height&quot;]]) # Print the plot&#39;s width, the plot&#39;s height, and the suggested scale limits. output$width &lt;- renderText(paste0(&quot;Plot&#39;s width: &quot;, width())) output$height &lt;- renderText(paste0(&quot;Plot&#39;s height: &quot;, height())) output$scale &lt;- renderText({ paste0(&quot;Recommended limits: (0, &quot;, max(height(), width()), &quot;)&quot;) }) # Store the distance computed by the click event. dist &lt;- reactiveVal(rep(1, nrow(df))) # Update the dist reactive as needed. observeEvent(input$plot_click, { req(input$plot_click) dist(nearPoints(df, input$plot_click, allRows = TRUE, addDist = TRUE)$dist_) }) output$plot &lt;- renderPlot({ df$dist &lt;- dist() ggplot(df, aes(x, y, size = dist)) + geom_point() }) } shinyApp(ui, server) "],["user-feedback.html", "Chapter 8 User Feedback", " Chapter 8 User Feedback There are no exercises in this chapter. "],["uploads-and-downloads.html", "Chapter 9 Uploads and Downloads", " Chapter 9 Uploads and Downloads Exercise 9.4.1 Use the ambient package by Thomas Lin Pedersen to generate worley noise and download a PNG of it. Solution. Solution A general method for saving a png file is to select the png driver using the function png(). The only argument the driver needs is a filename (this will be stored relative to your current working directory!). You will not see the plot when running the plot function because it is being saved to that file instead. When we’re done plotting, we used the dev.off() command to close the connection to the driver. library(ambient) noise &lt;- ambient::noise_worley(c(100, 100)) png(&quot;noise_plot.png&quot;) plot(as.raster(normalise(noise))) dev.off() Exercise 9.4.2 Create an app that lets you upload a csv file, select a variable, and then perform a t.test() on that variable. After the user has uploaded the csv file, you’ll need to use updateSelectInput() to fill in the available variables. See Section 10.1 for details. Solution. Solution We can use the fileInput widget with the accept argument set to .csv to allow only the upload of csv files. In the server function we save the uploaded data to the the data reactive and use it to update input$variable, which displays variable (i.e. numeric data column) choices. Note that we put the updateSelectInput within an observe event because we need the input$variable to change if the user selects another file. library(shiny) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( fileInput(&quot;file&quot;, &quot;Upload CSV&quot;, accept = &quot;.csv&quot;), # file widget selectInput(&quot;variable&quot;, &quot;Select Variable&quot;, choices = NULL) # select widget ), mainPanel( verbatimTextOutput(&quot;results&quot;) # t-test results ) ) ) server &lt;- function(input, output,session) { # get data from file data &lt;- reactive({ req(input$file) # as shown in the book, lets make sure the uploaded file is a csv ext &lt;- tools::file_ext(input$file$name) validate(need(ext == &quot;csv&quot;, &quot;Invalid file. Please upload a .csv file&quot;)) dataset &lt;- vroom::vroom(input$file$datapath, delim = &quot;,&quot;) # let the user know if the data contains no numeric column validate(need(ncol(dplyr::select_if(dataset, is.numeric)) != 0, &quot;This dataset has no numeric columns.&quot;)) dataset }) # create the select input based on the numeric columns in the dataframe observeEvent(input$file, { req(data()) num_cols &lt;- dplyr::select_if(data(), is.numeric) updateSelectInput(session, &quot;variable&quot;, choices = colnames(num_cols)) }) # print t-test results output$results &lt;- renderPrint({ if(!is.null(input$variable)) t.test(data()[input$variable]) }) } shinyApp(ui, server) Exercise 9.4.3 Create an app that lets the user upload a csv file, select one variable, draw a histogram, and then download the histogram. For an additional challenge, allow the user to select from .png, .pdf, and .svg output formats. Solution. Solution Adapting the code from the example above, rather than print a t-test output, we save the plot in a reactive and use it to display the plot/download. We can use the ggsave function to switch between input$extension types. library(shiny) library(ggplot2) ui &lt;- fluidPage( tagList( br(), br(), column(4, wellPanel( fileInput(&quot;file&quot;, &quot;Upload CSV&quot;, accept = &quot;.csv&quot;), selectInput(&quot;variable&quot;, &quot;Select Variable&quot;, choices = NULL), ), wellPanel( radioButtons(&quot;extension&quot;, &quot;Save As:&quot;, choices = c(&quot;png&quot;, &quot;pdf&quot;, &quot;svg&quot;), inline = TRUE), downloadButton(&quot;download&quot;, &quot;Save Plot&quot;) ) ), column(8, plotOutput(&quot;results&quot;)) ) ) server &lt;- function(input, output,session) { # get data from file data &lt;- reactive({ req(input$file) # as shown in the book, lets make sure the uploaded file is a csv ext &lt;- tools::file_ext(input$file$name) validate(need(ext == &quot;csv&quot;, &quot;Invalid file. Please upload a .csv file&quot;)) dataset &lt;- vroom::vroom(input$file$datapath, delim = &quot;,&quot;) # let the user know if the data contains no numeric column validate(need(ncol(dplyr::select_if(dataset, is.numeric)) != 0, &quot;This dataset has no numeric columns.&quot;)) dataset }) # create the select input based on the numeric columns in the dataframe observeEvent( input$file, { req(data()) num_cols &lt;- dplyr::select_if(data(), is.numeric) updateSelectInput(session, &quot;variable&quot;, choices = colnames(num_cols)) }) # plot histogram plot_output &lt;- reactive({ req(!is.null(input$variable)) ggplot(data()) + aes_string(x = input$variable) + geom_histogram() }) output$results &lt;- renderPlot(plot_output()) # save histogram using downloadHandler and plot output type output$download &lt;- downloadHandler( filename = function() { paste(&quot;histogram&quot;, input$extension, sep = &quot;.&quot;) }, content = function(file){ ggsave(file, plot_output(), device = input$extension) } ) } shinyApp(ui, server) Exercise 9.4.4 Write an app that allows the user to create a Lego mosaic from any .png file using Ryan Timpe’s brickr package. Once you’ve completed the basics, add controls to allow the user to select the size of the mosaic (in bricks), and choose whether to use “universal” or “generic” colour palettes. Solution. Solution Instead of limiting our file selection to a csv as above, here we are going to limit our input to a png. We’ll use the png::readPNG function to read in our file, and specify the size/color of our mosaic in brickr’s image_to_mosaic function. Read more about the package and examples here. library(shiny) library(brickr) library(png) # Function to provide user feedback (checkout Chapter 8 for more info). notify &lt;- function(msg, id = NULL) { showNotification(msg, id = id, duration = NULL, closeButton = FALSE) } ui &lt;- fluidPage( sidebarLayout( sidebarPanel( fluidRow( fileInput(&quot;myFile&quot;, &quot;Upload a PNG file&quot;, accept = c(&#39;image/png&#39;)), sliderInput(&quot;size&quot;, &quot;Select size:&quot;, min = 1, max = 100, value = 35), radioButtons(&quot;color&quot;, &quot;Select color palette:&quot;, choices = c(&quot;universal&quot;, &quot;generic&quot;)) ) ), mainPanel( plotOutput(&quot;result&quot;)) ) ) server &lt;- function(input, output) { imageFile &lt;- reactive({ if(!is.null(input$myFile)) png::readPNG(input$myFile$datapath) }) output$result &lt;- renderPlot({ req(imageFile()) id &lt;- notify(&quot;Transforming image...&quot;) on.exit(removeNotification(id), add = TRUE) imageFile() %&gt;% image_to_mosaic(img_size = input$size, color_palette = input$color) %&gt;% build_mosaic() }) } shinyApp(ui, server) "],["dynamic-ui.html", "Chapter 10 Dynamic UI", " Chapter 10 Dynamic UI This chapter is in development... Exercise 10.1.5.1 Complete the user interface below with a server function that updates input$date so that you can only select dates in input$year. ui &lt;- fluidPage( numericInput(&quot;year&quot;, &quot;year&quot;, value = 2020), dateInput(&quot;date&quot;, &quot;date&quot;) ) Solution. Solution This solution was a little wonky because it required shinyjs for the dateInput to properly update. I opened up an issue here since I think this is not the most intuitive answer. library(shiny) library(shinyjs) ui &lt;- fluidPage( useShinyjs() , numericInput(&quot;year&quot;, &quot;year&quot;, value = 2020), dateInput(&quot;date&quot;, &quot;date&quot;, value = Sys.Date()) ) server &lt;- function(input, output, session) { observeEvent(input$year, { req(input$year) # stop if year is blank daterange &lt;- range(as.Date(paste0(input$year, &quot;-01-01&quot;)),as.Date(paste0(input$year, &quot;-12-31&quot;))) updateDateInput(session, &quot;date&quot;, min = daterange[1], max = daterange[2] ) delay(250, # delay 250ms updateDateInput(session,&quot;date&quot;, value = daterange[1] )) }) } shinyApp(ui = ui, server = server) Exercise 10.1.5.2 Complete the user interface below with a server function that updates input$county choices based on input$state. For an added challenge, also change the label from “County” to “Parrish” for Louisana and “Borrough” for “Alaska”. library(openintro) states &lt;- unique(county$state) ui &lt;- fluidPage( selectInput(&quot;state&quot;, &quot;State&quot;, choices = states), selectInput(&quot;county&quot;, &quot;County&quot;, choices = NULL) ) Solution. Solution We can use updateSelectInput to filter the county choices based on the user selected state. By making the label of input$county a reactive, we can use switch to change the label when either Alaska or Louisiana is selected. library(shiny) library(tidyverse) library(openintro) states &lt;- unique(county$state) counties &lt;- unique(county$state) ui &lt;- fluidPage( selectInput(&quot;state&quot;, &quot;State&quot;, choices = states), selectInput(&quot;county&quot;, &quot;County&quot;, choices = NULL) ) server &lt;- function(input, output, session) { label &lt;- reactive({ switch(input$state, &quot;Alaska&quot; = &quot;Burrough&quot;, &quot;Louisiana&quot; = &quot;Parish&quot;, &quot;County&quot;) }) observeEvent( input$state, { updateSelectInput(session, &quot;county&quot;, label = label(), choices = county %&gt;% filter(state == input$state) %&gt;% select(name) %&gt;% distinct()) }) } shinyApp(ui = ui, server = server) Exercise 10.1.5.3 Complete the user interface below with a server function that updates input$country choices based on the input$continent. Use output$data to display all matching rows. library(gapminder) continents &lt;- unique(gapminder$continent) ui &lt;- fluidPage( selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = continents), selectInput(&quot;country&quot;, &quot;Country&quot;, choices = NULL), tableOutput(&quot;data&quot;) ) Solution. Solution As the question above, we are filtering the country input based on the continent by using updateSelectInput in the server. By storing the selected data in a reactive, selected_data() we can use the same filtered dataset for our selectInput and the table, reducing code redundancy. library(shiny) library(gapminder) continents &lt;- unique(gapminder$continent) ui &lt;- fluidPage( selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = c(&quot;&quot;, as.character(continents))), selectInput(&quot;country&quot;, &quot;Country&quot;, choices = NULL), tableOutput(&quot;data&quot;) ) server &lt;- function(input, output, session) { selected_data &lt;- reactive({ if(input$continent %in% continents) { gapminder %&gt;% filter(continent == input$continent) } else { gapminder } }) observeEvent( input$continent, { updateSelectInput(session, &quot;country&quot;, &quot;Country&quot;, choices = selected_data() %&gt;% select(country) %&gt;% distinct()) }) output$data &lt;- renderTable({ selected_data() %&gt;% filter(country == input$country) }) } shinyApp(ui = ui, server = server) Exercise 10.1.5.4 Extend the previous app so that you can also choose to select no continent, and hence see all countries. You’ll need to add &quot;&quot; to the list of choices, and then handle that specially when filtering. Solution. Solution Initially setting the choices to c(&quot;&quot;, as.character(continents)) allows the user to see all the Country options prior to a continent being selected. That said, once a continent is selected this &quot;&quot; option is no longer available. library(shiny) library(gapminder) continents &lt;- unique(gapminder$continent) ui &lt;- fluidPage( selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = c(&quot;&quot;, as.character(continents))), # @tanho63: # selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = c(&quot;All&quot;, as.character(continents))), selectInput(&quot;country&quot;, &quot;Country&quot;, choices = NULL), tableOutput(&quot;data&quot;) ) server &lt;- function(input, output, session) { selected_data &lt;- reactive({ if(input$continent %in% continents) { gapminder %&gt;% filter(continent == input$continent) } else { gapminder } }) observeEvent( input$continent, { # @tanho63: updateSelectInput(session, &quot;country&quot;, choices = unique(selected_data()$country)) }) output$data &lt;- renderTable({ selected_data() %&gt;% filter(country == input$country) }) } shinyApp(ui = ui, server = server) Exercise 10.1.5.5 What is at the heart of the problem described at https://community.rstudio.com/t/29307? Solution. Solution Updating all three sliders creates a circular reference! Exercise 10.2.3.1 Use a hidden tabset to show additional controls only if the user checks an “advanced” check box. Exercise 10.2.3.2 Create that allows the user to select from geom_smooth(), geom_histogram(), or geom_point(). Use a hidden tabset to allow the user to select different options depending on the geom. geom_smooth() should have a text both for the model, and checkbox for whether or not to add standard errors. geom_histogram() should have a numeric input for the bin width, and geom_point() doesn’t need any additional options. Exercise 10.2.3.3 Create a wizard interface that steers the user along the path … Exercise 10.3.4.1 Take this very simple app based on the initial example in the chapter: ui &lt;- fluidPage( selectInput(&quot;type&quot;, &quot;type&quot;, c(&quot;slider&quot;, &quot;numeric&quot;)), uiOutput(&quot;numeric&quot;) ) server &lt;- function(input, output, session) { output$numeric &lt;- renderUI({ if (input$type == &quot;slider&quot;) { sliderInput(&quot;n&quot;, &quot;n&quot;, value = 0, min = 0, max = 100) } else { numericInput(&quot;n&quot;, &quot;n&quot;, value = 0, min = 0, max = 100) } }) } How could you instead implement it using dynamic visibility? If you implement dynamic visibility, how could you keep the values in sync when you change the controls? Solution. Solution library(shiny) parameter_tabs &lt;- tagList( tags$style(&quot;#params { display:none; }&quot;), tabsetPanel(id = &quot;params&quot;, tabPanel(&quot;slider&quot;, sliderInput(&quot;my_slider&quot;, &quot;n&quot;, value = 0, min = 0, max = 100) ), tabPanel(&quot;numeric&quot;, numericInput(&quot;my_numeric&quot;, &quot;n&quot;, value = 0, min = 0, max = 100) ) ) ) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( selectInput(&quot;my_selector&quot;, &quot;Input Type&quot;, choices = c(&quot;slider&quot;, &quot;numeric&quot;) ), parameter_tabs, ), mainPanel() ) ) server &lt;- function(input, output, session) { # if slider changes, update numeric observeEvent( input$my_slider, { updateNumericInput(session, &quot;my_numeric&quot;, value = isolate(input$my_slider)) }) # if numeric changes update slider observeEvent( input$my_numeric, { updateSliderInput(session, &quot;my_slider&quot;, value = isolate(input$my_numeric)) }) observeEvent(input$my_selector, { updateTabsetPanel(session, &quot;params&quot;, selected = input$my_selector) }) } shinyApp(ui = ui, server = server) Exercise 10.3.4.2 Explain how this app works. Why does the password disappear when you click the enter password button for the second time? ui &lt;- fluidPage( actionButton(&quot;go&quot;, &quot;Enter password&quot;), textOutput(&quot;text&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$go, { showModal(modalDialog( passwordInput(&quot;password&quot;, NULL), title = &quot;Please enter your password&quot; )) }) output$text &lt;- renderText({ if (!isTruthy(input$password)) { &quot;No password&quot; } else { &quot;Password entered&quot; } }) } Exercise 10.3.4.3 Add support for date and date-time columns make_ui() and filter_var(). Solution. Solution In order to complete this, I had to make a new dummy dataframe I called x in order to test for dates include checking for is.Date in the make_ui and filter_var functions Change tableOutput and renderTable to DT::renderTableOutput and DT::renderTableOutput because renderTable was rendering the dates as numbers and I think this could be because it uses xtable() for HTML table rendering? # 8.4.3.2 library(shiny) library(purrr) library(tidyverse) make_ui &lt;- function(x, var) { if (is.numeric(x)) { rng &lt;- range(x, na.rm = TRUE) sliderInput(var, var, min = rng[1], max = rng[2], value = rng) } else if (is.factor(x)) { levs &lt;- levels(x) selectInput(var, var, choices = levs, selected = levs, multiple = TRUE) } else if (lubridate::is.Date(x)) { rng &lt;- range(x, na.rm = TRUE) dateInput(var, var, min = rng[1], max = rng[2], value = rng[1]) } else { # No control, so don&#39;t filter NULL } } filter_var &lt;- function(x, val) { if (is.numeric(x)) { !is.na(x) &amp; x &gt;= val[1] &amp; x &lt;= val[2] } else if (is.factor(x)) { x %in% val } else if (lubridate::is.Date(x)) { x %in% val } else { TRUE } } library(shiny) dfs &lt;- keep(ls(&quot;package:datasets&quot;), ~ is.data.frame(get(.x, &quot;package:datasets&quot;))) # add a dataframe with dates in it since I cant find one in the datasets above # rep 5 dates five times, each include 1 factor a-e x &lt;- data.frame(date = c(rep(as.Date(&quot;2020/1/1&quot;), 5), rep(as.Date(&quot;2020/2/2&quot;), 5), rep(as.Date(&quot;2020/3/3&quot;), 5), rep(as.Date(&quot;2020/4/4&quot;), 5), rep(as.Date(&quot;2020/5/5&quot;), 5)), fac = as.factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( #selectInput(&quot;dataset&quot;, label = &quot;Dataset&quot;, choices = c(dfs, &quot;x&quot;)), uiOutput(&quot;filter&quot;) ), mainPanel( DT::dataTableOutput(&quot;data&quot;) ) ) ) server &lt;- function(input, output, session) { # data is either my dummy dataset or from datasets data &lt;- reactive(x) vars &lt;- reactive(names(data())) output$filter &lt;- renderUI( # take eahc column name and make ui # data()[[.x]] is each column # and .x is each column name (vars()) map(vars(), ~ make_ui(data()[[.x]], .x)) ) selected &lt;- reactive({ # take each column name and filer var # with the first argument the column in the data # and the second argument the input$vars() # so for date check that input[[date]] in data[[1]] each_var &lt;- map(vars(), ~ filter_var(data()[[.x]], input[[.x]])) # notes from @mapaulacaldas # collapse list of TRUE and FALSE using `&amp;` # conditions &lt;- list(TRUE, TRUE, TRUE, FALSE) # purrr::reduce(conditions, `&amp;`) == # ((conditions[[1]] &amp; conditions[[2]]) &amp; conditions[[3]]) &amp; conditions[[4]] reduce(each_var, `&amp;`) }) # subset the data by the vars that are true output$data &lt;- DT::renderDataTable(data()[selected(), ]) } # Run the application shinyApp(ui = ui, server = server) Exercise 10.3.4.4 (Advanced) If you know the S3 OOP system, consider how you could replace the if blocks in make_ui() and filter_var() with generic functions. Solution. Solution library(shiny) library(purrr) make_ui &lt;- function(obj, var) { UseMethod(&quot;make_ui&quot;) } make_ui.numeric &lt;- function(x, var) { rng &lt;- range(x, na.rm = TRUE) sliderInput(var, var, min = rng[1], max = rng[2], value = rng) } make_ui.factor &lt;- function(x, var) { levs &lt;- levels(x) selectInput(var, var, choices = levs, selected = levs, multiple = TRUE) } make_ui.default &lt;- function(x, var) { NULL } filter_var &lt;- function(x, val) { UseMethod(&quot;filter_var&quot;) } filter_var.numeric &lt;- function(x, val) { !is.na(x) &amp; x &gt;= val[1] &amp; x &lt;= val[2] } filter_var.factor &lt;- function(x, val) { x %in% val } filter_var.default &lt;- function(x, val) { TRUE } dfs &lt;- keep(ls(&quot;package:datasets&quot;), ~ is.data.frame(get(.x, &quot;package:datasets&quot;))) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( selectInput(&quot;dataset&quot;, label = &quot;Dataset&quot;, choices = dfs), uiOutput(&quot;filter&quot;) ), mainPanel( tableOutput(&quot;data&quot;) ) ) ) server &lt;- function(input, output, session) { data &lt;- reactive({ get(input$dataset, &quot;package:datasets&quot;) }) vars &lt;- reactive(names(data())) output$filter &lt;- renderUI( map(vars(), ~ make_ui(data()[[.x]], .x)) ) selected &lt;- reactive({ each_var &lt;- map(vars(), ~ filter_var(data()[[.x]], input[[.x]])) reduce(each_var, `&amp;`) }) output$data &lt;- renderTable(head(data()[selected(), ], 12)) } shinyApp(ui = ui, server = server) Exercise 10.3.4.5 (Hard) Make a wizard that allows the user to upload their own dataset. The first page should handle the upload. The second should handle reading it, providing one drop down for each variable that lets the user select the column type. The third page should provide some way to get a summary of the dataset. Solution. Solution I wasn’t really sure what was meant by “some way to get a summary of the dataset” So I’m just using the summary function. library(shiny) library(readr) make_dropdown &lt;- function(name_of_vector) { selectInput(inputId = name_of_vector, label = name_of_vector, choices = c(&quot;numeric&quot;, &quot;character&quot;, &quot;logical&quot;)) } ui &lt;- fluidPage( tags$style(&quot;#wizard { display:none; }&quot;), tabsetPanel(id = &quot;wizard&quot;, tabPanel(&quot;page1&quot;, fileInput(&quot;data_input&quot;, &quot;input&quot;), actionButton(&quot;page12&quot;, &quot;next&quot;) ), tabPanel(&quot;page2&quot;, sidebarLayout( sidebarPanel( uiOutput(&quot;type_of&quot;) ), mainPanel( tableOutput(&#39;type_table&#39;) )), actionButton(&quot;page21&quot;, &quot;prev&quot;), actionButton(&quot;page23&quot;, &quot;next&quot;) ), tabPanel(&quot;page3&quot;, tableOutput(&quot;summary_table&quot;), actionButton(&quot;page32&quot;, &quot;prev&quot;) ) ) ) server &lt;- function(input, output, session) { ################ WIZARD ############################### switch_tab &lt;- function(page) { updateTabsetPanel(session, &quot;wizard&quot;, selected = page) } observeEvent(input$page12, switch_tab(&quot;page2&quot;)) observeEvent(input$page21, switch_tab(&quot;page1&quot;)) observeEvent(input$page23, switch_tab(&quot;page3&quot;)) observeEvent(input$page32, switch_tab(&quot;page2&quot;)) ##################### FILE INPUT ####################### dat &lt;- reactive({ req(input$data_input) read.csv(input$data_input$datapath) }) ##################### TABLE TYPE ####################### # make a dropdown using the names of each column output$type_of &lt;- renderUI({ map(names(dat()), ~ make_dropdown(.x)) }) # switch the type of column based on the input # name of vector == &quot;Sepal.Length&quot; # vector == Sepal.Length change_type &lt;- function(vector, name_of_vector) { switch(input[[name_of_vector]], &quot;numeric&quot; = vector &lt;- as.numeric(vector), &quot;character&quot; = vector &lt;- as.character(vector), &quot;logical&quot; = vector &lt;- as.complex(vector) ) } # convert the supplied data to a list # use imap because it is a condensed version o map # with two arguments == x &amp; name_of_x # so we don&#39;t need to supply it arguments beyond the list! df&lt;- reactive({ dat() %&gt;% as.list() %&gt;% imap(change_type) %&gt;% as_tibble() }) # create an output of the data&#39;s names # and their types output$type_table &lt;- renderTable(data.frame( names = names(df()), type = map_chr(df(), function(x) typeof(x))) ) ##################### TABLE OUTPUT ##################### output$summary_table &lt;- renderTable( summary(df()) ) } shinyApp(ui = ui, server = server) "],["bookmarking.html", "Chapter 11 Bookmarking", " Chapter 11 Bookmarking This chapter is in development... Exercise 11.3.1 Generate app for visualising the results of noise::ambient_simplex(). Your app should allow the user to control the frequency, fractal, lacunarity, and gain, and be bookmarkable. How can you ensure the image looks exactly the same when reloaded from the bookmark? (Think about what the seed argument implies). Solution. Solution For this example, we’ll use the bookmarking by setting enableBookmarking = &quot;url&quot; within the shinyApp function. In order to ensure the simulation is the same each time we re-render the bookmark we’ll create a grid to use for points then set the seed to 42 to ensure the same image is rendered when the bookmark is loaded. library(shiny) library(ambient) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( sliderInput(&quot;frequency&quot;, &quot;Frequency&quot;, min = 0, max = 1, value = 0.01), selectInput(&quot;fractal&quot;, &quot;Fractal&quot;, choices = c(&quot;none&quot;, &quot;fbm&quot;, &quot;billow&quot;, &quot;rigid-multi&quot;)), sliderInput(&quot;gain&quot;, &quot;Gain&quot;, min = 0, max = 1, value = 0.5), ), mainPanel( plotOutput(&quot;result&quot;) ) ) ) server &lt;- function(input, output, session) { grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000)) noise &lt;- reactive({ ambient::gen_simplex( x = grid$x, y = grid$y, seed = 42, frequency = input$frequency, fractal = input$fractal, gain = input$gain ) }) output$result &lt;- renderPlot({ plot(grid, noise()) }) observe({ reactiveValuesToList(input) session$doBookmark() }) onBookmarked(updateQueryString) } shinyApp(ui = ui, server = server, enableBookmarking = &quot;url&quot;) Exercise 11.3.2 Make a simple app that lets you upload a csv file and then bookmark it. Upload a few files and then look in shiny_bookmarks. How do the files correspond to the bookmarks? (Hint: you can use readRDS() to look inside the cache files that Shiny is generating). Solution. Solution By setting the state$values$data equal to the data reactive, we can store the contents of the uploaded csv. Looking in the shiny_bookmarks folder we see an input.rds which has the same 4 arguments as input$file: name size type datapath All of these except the datapath are the same as when we upload the file; rather than the temporary location the file is saved to within the shiny session, the datapath becomes 0.csv, a csv file created within the same folder are our input.RDS. library(shiny) ui &lt;- function(request){ fluidPage( sidebarLayout( sidebarPanel( bookmarkButton(), fileInput(&quot;file&quot;, &quot;Choose CSV File&quot;, multiple = TRUE,accept = &quot;.csv&quot;) ), mainPanel( tableOutput(&quot;contents&quot;) ) ) ) } server &lt;- function(input, output) { # create reactive of input file data &lt;- reactive({ req(input$file) read.csv(input$file$datapath) }) # display head output$contents &lt;- renderTable( head(data()) ) # set the state to the df reactive onBookmark(function(state){ state$values$data &lt;- data() }) # on restore set df to the state onRestore(function(state){ data &lt;- reactive(state$values$data) }) enableBookmarking(store=&quot;server&quot;) } shinyApp(ui, server) "],["tidy-evaluation.html", "Chapter 12 Tidy Evaluation", " Chapter 12 Tidy Evaluation There are no exercises in this chapter. "],["general-guidelines.html", "Chapter 13 General Guidelines", " Chapter 13 General Guidelines There are no exercises in this chapter. "],["functions.html", "Chapter 14 Functions", " Chapter 14 Functions This chapter is in development... Exercise 14.4.1 The following app plots user selected variables from the msleep dataset for three different types of mammals (carnivores, omnivores, and herbivores), with one tab for each type of mammal. Remove the redundancy in the selectInput() definitions with the use of functions. library(tidyverse) ui &lt;- fluidPage( selectInput(inputId = &quot;x&quot;, label = &quot;X-axis:&quot;, choices = c(&quot;sleep_total&quot;, &quot;sleep_rem&quot;, &quot;sleep_cycle&quot;, &quot;awake&quot;, &quot;brainwt&quot;, &quot;bodywt&quot;), selected = &quot;sleep_rem&quot;), selectInput(inputId = &quot;y&quot;, label = &quot;Y-axis:&quot;, choices = c(&quot;sleep_total&quot;, &quot;sleep_rem&quot;, &quot;sleep_cycle&quot;, &quot;awake&quot;, &quot;brainwt&quot;, &quot;bodywt&quot;), selected = &quot;sleep_total&quot;), tabsetPanel(id = &quot;vore&quot;, tabPanel(&quot;Carnivore&quot;, plotOutput(&quot;plot_carni&quot;)), tabPanel(&quot;Omnivore&quot;, plotOutput(&quot;plot_omni&quot;)), tabPanel(&quot;Herbivore&quot;, plotOutput(&quot;plot_herbi&quot;))) ) server &lt;- function(input, output, session) { # make subsets carni &lt;- reactive( filter(msleep, vore == &quot;carni&quot;) ) omni &lt;- reactive( filter(msleep, vore == &quot;omni&quot;) ) herbi &lt;- reactive( filter(msleep, vore == &quot;herbi&quot;) ) # make plots output$plot_carni &lt;- renderPlot({ ggplot(data = carni(), aes_string(x = input$x, y = input$y)) + geom_point() }, res = 96) output$plot_omni &lt;- renderPlot({ ggplot(data = omni(), aes_string(x = input$x, y = input$y)) + geom_point() }, res = 96) output$plot_herbi &lt;- renderPlot({ ggplot(data = herbi(), aes_string(x = input$x, y = input$y)) + geom_point() }, res = 96) } shinyApp(ui = ui, server = server) Solution. Solution We can see a pattern here where we are creating the same type of plot for each tabset panel, with the only variable changing being the vore argument. We can reduce everything we see in triplicate to functions! We can use map to create a single create_panels function which will create a tab for each of our species. On the server side, the data is filtered three times, and the plots are created three times. We can create a single rendering function that given the correct string it will filter the data, create the correct plot, and assign it to the correct output. library(tidyverse) # use a vector for function inputs species &lt;- c(&quot;Carnivore&quot;, &quot;Omnivore&quot;, &quot;Herbivore&quot;) # educe to a single UI function # Marly: this didn&#39;t work! create_panels &lt;- function(id) { tabPanel(id, plotOutput(paste0(&quot;plot_&quot;, id))) } ui &lt;- fluidPage( selectInput(inputId = &quot;x&quot;, label = &quot;X-axis:&quot;, choices = c(&quot;sleep_total&quot;, &quot;sleep_rem&quot;, &quot;sleep_cycle&quot;, &quot;awake&quot;, &quot;brainwt&quot;, &quot;bodywt&quot;), selected = &quot;sleep_rem&quot;), selectInput(inputId = &quot;y&quot;, label = &quot;Y-axis:&quot;, choices = c(&quot;sleep_total&quot;, &quot;sleep_rem&quot;, &quot;sleep_cycle&quot;, &quot;awake&quot;, &quot;brainwt&quot;, &quot;bodywt&quot;), selected = &quot;sleep_total&quot;), tabsetPanel( tabPanel(&quot;Carnivore&quot;, plotOutput(&quot;plot_Carnivore&quot;)), tabPanel(&quot;Omnivore&quot;, plotOutput(&quot;plot_Omnivore&quot;)), tabPanel(&quot;Herbivore&quot;, plotOutput(&quot;plot_Herbivore&quot;)) ) # this works without the tabsetPanel function - why?! # purrr::map(species, create_panels) ) server &lt;- function(input, output, session) { # rendering plot function for each panel render_outputs &lt;- function(id) { output[[paste0(&quot;plot_&quot;, id)]] &lt;- renderPlot({ msleep %&gt;% filter(vore == tolower(stringr::str_remove(id, &quot;vore&quot;)) %&gt;% ggplot() + aes_string(x = input$x, y = input$y) + geom_point() ) }) } # apply to the species vector using map purrr::map(species, render_outputs) } shinyApp(ui = ui, server = server) Exercise 14.4.2 Continue working with the same app from the previous exercise, and further remove redundancy in the code by modularizing how subsets and plots are created. Solution. Solution TODO: I’m unsure what to do with this one since we haven’t yet introduced modules? Exercise 14.4.3 Suppose you have an app that is slow to launch when a user visits it. Can modularizing your app code help solve this problem? Explain your reasoning. Solution. Solution No, we’re just packaging our code into neater functions - this doesn’t change or optimize what is loaded when the app is launched. In fact, modularizing might even make your application slower in some cases. "],["modules.html", "Chapter 15 Modules", " Chapter 15 Modules This chapter is in development... Exercise 15.6.1 Example passing input$foo to reactive and it not working. Solution. Solution I don’t really know what this question is asking, but I think the point is to remember: The main challenge with this sort of code is remembering when you use the reactive (e.g. x$value) vs. when you use its value (e.g. x$value()). Just remember that when passing an argument to a module, you want the module to react to the value changing which means that you have to pass the reactive, not it’s current value. Where in this scenario, input$foo is analogous to x$value. Exercise 15.6.2 Rewrite selectVarServer() so that both data and filter are reactive. Pair it with a app function that lets the user pick the dataset with the dataset module, a function with an inputSelect() that lets the user filter for numeric, character, or factor variables. Solution. Solution The modules datasetInput, datasetServer, and selectVarInput are the same, as well as the find_vars function. We can start by creating selectFilterInput which has the filtering options as choices, and selectFilterServer which returns the filtering function given the selected choice string. # create a filter selection input selectFilterInput &lt;- function(id) { selectInput(NS(id, &quot;filter&quot;), &quot;Filter&quot;, choices = c(&quot;Numeric&quot;, &quot;Character&quot;, &quot;Factor&quot;), selected = &quot;Numeric&quot;) } # switch the function to be applied within the server selectFilterServer &lt;- function(id) { moduleServer(id, function(input, output, session) { eventReactive(input$filter, { switch(input$filter, &quot;Numeric&quot; = is.numeric, &quot;Character&quot; = is.character, &quot;Factor&quot; = is.factor ) }) }) } Now we can update the selectVarServer to take on an additional filter argument, and change the update function to not only observe when the data reactive changes but also our new filter widget changes. Lastly we pass in the filter reactive to the find_vars function. selectVarServer &lt;- function(id, data, filter) { # filter argument moduleServer(id, function(input, output, session) { observeEvent({ data() filter() #observe changes in filter reactive }, { updateSelectInput(session, &quot;var&quot;, choices = find_vars(data(), filter())) # filter as reactive }) reactive(data()[[input$var]]) }) } Putting it together, we add our new module to the UI and server, and by saving the result of the selectFilterServer to filt we can pass that to the selectVarServer selectVarApp &lt;- function() { ui &lt;- fluidPage( datasetInput(&quot;data&quot;, is.data.frame), # call the new filter UI selectFilterInput(&quot;filter&quot;), selectVarInput(&quot;var&quot;), verbatimTextOutput(&quot;out&quot;) ) server &lt;- function(input, output, session) { data &lt;- datasetServer(&quot;data&quot;) # store the filtering function as a reactive filt &lt;- selectFilterServer(&quot;filter&quot;) # pass the reactive to the select module var &lt;- selectVarServer(&quot;var&quot;, data, filter = filt) output$out &lt;- renderPrint(var()) } shinyApp(ui, server) } Exercise 15.6.3 The following code defines output and server components of a module that takes a numeric input and produces a bulleted list of three summary statistics. Create an app function that allows you to experiment with it. The app function should take a data frame as input, and use numericVarSelectInput() to pick the variable to summarise. summaryOuput &lt;- function(id) { tags$ul( tags$li(&quot;Min: &quot;, textOutput(NS(id, &quot;min&quot;), inline = TRUE)), tags$li(&quot;Max: &quot;, textOutput(NS(id, &quot;max&quot;), inline = TRUE)), tags$li(&quot;Missing: &quot;, textOutput(NS(id, &quot;n_na&quot;), inline = TRUE)) ) } summaryServer &lt;- function(id, var) { moduleServer(id, function(input, output, session) { rng &lt;- reactive({ req(var()) range(var(), na.rm = TRUE) }) output$min &lt;- renderText(rng()[[1]]) output$max &lt;- renderText(rng()[[2]]) output$n_na &lt;- renderText(sum(is.na(var()))) }) } Solution. Solution We only need to add the code above to the selectVarApp() example in the book, and adapt the app code to include the summaryOutput instead of the verbatimTextOutput, and on the server side pass var to the summaryServer function instead of to the text output. selectVarApp &lt;- function(filter = is.numeric) { ui &lt;- fluidPage( datasetInput(&quot;data&quot;, is.data.frame), selectVarInput(&quot;var&quot;), summaryOutput(&quot;summary&quot;) ) server &lt;- function(input, output, session) { data &lt;- datasetServer(&quot;data&quot;) var &lt;- selectVarServer(&quot;var&quot;, data, filter = filter) summaryServer(&quot;summary&quot;, var) } shinyApp(ui, server) } selectVarApp() Exercise 15.6.4 The following module input provides a text control that lets you type a date in ISO8601 format (yyyy-mm-dd). Complete the module by providing a server function that uses output$error to display a message if the entered value is not a valid date. The module should return a Date object for valid dates. (Hint: use strptime(x, “%Y-%m-%d”) to parse the string; it will return NA if the value isn’t a valid date.) ymdDateUI &lt;- function(id, label) { label &lt;- paste0(label, &quot; (yyyy-mm-dd)&quot;) fluidRow( textInput(NS(id, &quot;date&quot;), label), textOutput(NS(id, &quot;error&quot;)) ) } Solution. Solution We create a ymdDateServer function that renders the error if strptime(input$date, &quot;%Y-%m-%d&quot;) is NA. ymdDateServer &lt;- function(id, label) { moduleServer(id, function(input, output, session) { output$error &lt;- renderText({ print(input$date) print(strptime(input$date, &quot;%Y-%m-%d&quot;)) if (!is.na(strptime(input$date, &quot;%Y-%m-%d&quot;)) | input$date == &quot;&quot;) { NULL } else { &quot;Entered value is not a proper date&quot; } }) }) } We put the UI and Server code together in the ymdApp function below: ymdApp &lt;- function(filter = is.numeric) { ui &lt;- fluidPage( ymdDateUI(&quot;ymd&quot;, &quot;Time&quot;) ) server &lt;- function(input, output, session) { ymdDateServer(&quot;ymd&quot;) } shinyApp(ui, server) } ymdApp() Exercise 15.6.5 In radioExtraServer(), return a list that contains both the value and whether or not it came from other. Solution. Solution We can adapt the reactive we return from radioExtraServer to return both the reactive and whether it came from the primary button choices or not as a list. radioExtraServer &lt;- function(id) { moduleServer(id, function(input, output, session) { observeEvent(input$other, ignoreInit = TRUE, { updateRadioButtons(session, &quot;primary&quot;, selected = &quot;other&quot;) }) selected &lt;- reactive({ if (input$primary == &quot;other&quot;) { input$other } else { input$primary } }) # return the selected reactive inside a list # adding whether it came from primary or not list(selected = reactive({ if (input$primary == &quot;other&quot;) { input$other } else { input$primary } }), primary = reactive(input$primary != &quot;other&quot;) ) }) } In doing so, we need to adapt the radioExtraApp code to return extra$selected() rather than extra. radioExtraApp &lt;- function(...) { ui &lt;- fluidPage( radioExtraUI(&quot;extra&quot;, NULL, ...), textOutput(&quot;value&quot;) ) server &lt;- function(input, output, server) { extra &lt;- radioExtraServer(&quot;extra&quot;) output$value &lt;- renderText({ paste0(&quot;Selected: &quot;, extra$selected()) }) } shinyApp(ui, server) } radioExtraApp(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) Exercise 15.6.6 In wizardServer() verify that the namespacing has been set up correctly by using two or more wizards in a single add, and checking that you can navigate through each wizard independently. Solution. Solution "],["packages.html", "Chapter 16 Packages", " Chapter 16 Packages There are no exercises in this chapter. "],["testing.html", "Chapter 17 Testing", " Chapter 17 Testing There are no exercises in this chapter. "],["safety.html", "Chapter 18 Safety", " Chapter 18 Safety There are no exercises in this chapter. "],["performance.html", "Chapter 19 Performance", " Chapter 19 Performance There are no exercises in this chapter. "],["why-reactivity.html", "Chapter 20 Why reactivity?", " Chapter 20 Why reactivity? There are no exercises in this chapter. "],["dependency-tracking.html", "Chapter 21 Dependency Tracking", " Chapter 21 Dependency Tracking There are no exercises in this chapter. "],["scoping.html", "Chapter 22 Scoping", " Chapter 22 Scoping There are no exercises in this chapter. "],["reactive-components.html", "Chapter 23 Reactive Components", " Chapter 23 Reactive Components There are no exercises in this chapter. "],["advanced-ui.html", "Chapter 24 Advanced UI", " Chapter 24 Advanced UI There are no exercises in this chapter. "]]
